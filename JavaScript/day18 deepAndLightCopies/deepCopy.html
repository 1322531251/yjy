<!-- 
    深拷贝：
    只针对于引用类型

    拷贝的是对象，不是地址

    常见方法：
    1.通过递归实现深拷贝
    函数递归：
    如果一个函数在内部可以调用本身，那么这个函数就是递归函数
    由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件return

    利用递归函数实现setTimeout模拟setInterval效果


    2.lodash/ _.cloneDeep(拷贝对象)
    3.通过JSON.stringify()实现
 -->

 <!DOCTYPE html>
 <html lang="en">
 <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>深拷贝</title>
 </head>
 <body>
    
    <script>
        // let i = 1
        // function fn(){
        //     console.log(`第${i}次打印`);
        //     if(i >=6){
        //         return
        //     }
        //     i++
        //     fn()
        // }
        // fn()

        const obj = {
            uname:'red',
            age:18,
            hobby:['篮球','足球'],
            family:{
                baby:'blue'
            }
        }
        const o ={}
        function deepCopy(newObj,oldObj) {  

            // 遍历
            // k是属性名 oldObj[k]属性值
            for(let k in oldObj){
                // 判断对象中的属性值
                if(oldObj[k] instanceof Array){
                    newObj[k] = []
                    deepCopy(newObj[k],oldObj[k])
                }else if(oldObj[k] instanceof Object){
                    newObj[k] = {}
                    deepCopy(newObj[k],oldObj[k])
                }else{
                // newObj[k] === o.uname 给新对象添加属性
                newObj[k] = oldObj[k]
                }
            }
        }
        deepCopy(o,obj)
        console.log(o);
        o.age = 10
        o.hobby[0] = '羽毛球'
        o.family.baby = 'yellow'
        console.log(obj);
        // console.log(o);
    </script>
 </body>
 </html>