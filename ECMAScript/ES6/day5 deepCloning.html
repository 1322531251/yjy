<!-- 
    拷贝数据：
        基本数据类型：
            拷贝后会生成一份新的数据，修改拷贝以后的数据不会影响原数据
        对象/数据
            拷贝后不会生成新的数据，而是拷贝引用，修改拷贝之后的数据会影响原来的数据
    
    拷贝数据的方法：
    1.直接赋值给一个变量  //浅拷贝
    2.Object.assign()  //浅拷贝
    3.Array.prototype.concat()  //浅拷贝
    4.Array.prototype.slick()  //浅拷贝
    5.JSON.parse(JSON.stringify())  //深拷贝（深度克隆   拷贝数据不能有函数，处理不了

    浅拷贝（对象/数组：
        特点：拷贝的是引用，修改拷贝以后的数据会影响原数据，使得原数据不安全
    深拷贝（深度克隆：
        特点：拷贝的时候生成新数据，修改拷贝以后的数据不会影响原数据


    检测数据类型的方式：
    typeof返回的数据类型：String，Number，Boolean，Undefined，Object，Function

 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>deepCloning</title>
</head>
<body>
    

    <script type="text/javascript">
        // let str = 'abc'
        // let str2 = str
        // console.log(str2);
        // str2 = ' '
        // console.log(str);

        // // 拷贝数组/对象 没有生成新的数据而是复制了一份引用
        // let obj = {uname:'lili', age:15}
        // let obj1 = obj
        // console.log(obj1);
        // obj1.uname = 'mingming'
        // console.log(obj.uname);

        // let arr = [1,5,{uname:'lili',age:15}]
        // let arr1 = arr
        // arr1[0] = 'abc'
        // console.log(arr,arr1);



        let obj = {uname:'lili',age:15}
        let obj2 = Object.assign(obj)
        console.log(obj2);
        obj2.uname = 'peter'
        console.log(obj);

        let arr = [1,2,{uname:'lili'}]
        let arr2 = arr.concat()
        console.log(arr2);

        arr2[1] = 'a'
        console.log(arr);        
        arr2[2].uname = 'peter'
        console.log(arr);
        let arr3 = arr.slice()
        arr3[2].uname = 'lili'
        console.log(arr);


        let arr4 = JSON.parse(JSON.stringify(arr))
        console.log(arr4);
        arr4[2] = 'peter'
        console.log(arr);


        
    </script>
</body>
</html> 